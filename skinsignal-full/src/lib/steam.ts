export function normalizeSteamId(raw:string){const s=String(raw||"").trim(); if(!/^[0-9]{17}$/.test(s)) throw new Error("invalid_steam_id: expected 17-digit SteamID64"); return s;}
async function fetchPrimary(id:string){return fetch(`https://steamcommunity.com/inventory/${id}/730/2?l=en&count=5000`,{cache:"no-store"})}
async function fetchLegacy(id:string){return fetch(`https://steamcommunity.com/profiles/${id}/inventory/json/730/2`,{cache:"no-store"})}
function normLegacy(j:any){const inv=j?.rgInventory||{}; const desc=j?.rgDescriptions||{}; const assets=Object.values(inv).map((a:any)=>({appid:730,classid:String(a.classid),instanceid:String(a.instanceid||"0"),amount:String(a.amount||"1")})); const descriptions=Object.values(desc).map((d:any)=>({appid:730,classid:String(d.classid),instanceid:String(d.instanceid||"0"),market_hash_name:d.market_hash_name||d.name,name:d.name})); return {assets,descriptions};}
export async function fetchSteamInventory(raw:string){const id=normalizeSteamId(raw); for(let i=0;i<2;i++){const r=await fetchPrimary(id); if(r.ok){const j=await r.json().catch(()=>null); if(j&&Array.isArray(j.assets)&&Array.isArray(j.descriptions)) return j; throw new Error("steam_invalid_payload") } if(![400,401,403,404].includes(r.status)){ await new Promise(r2=>setTimeout(r2,800)); continue;} break;} const r2=await fetchLegacy(id); if(!r2.ok){const t=await r2.text().catch(()=>""); throw new Error(`steam_fetch_failed: ${r2.status}${t?" body="+JSON.stringify(t.slice(0,500)):""}`)} const j2=await r2.json().catch(()=>null); if(!j2||j2.success!==true) throw new Error("steam_legacy_failed"); const n=normLegacy(j2); if(!Array.isArray(n.assets)||!Array.isArray(n.descriptions)) throw new Error("steam_legacy_invalid_payload"); return n;}
export function aggregateInventory(raw:any){const assets=raw.assets||[]; const descs=raw.descriptions||[]; const key=new Map<string,string>(); for(const d of descs){const k=`${d.classid}_${d.instanceid}`; const name=d.market_hash_name||d.name; if(k&&name) key.set(k,name);} const counts=new Map<string,number>(); for(const a of assets){const n=key.get(`${a.classid}_${a.instanceid}`); if(!n) continue; counts.set(n,(counts.get(n)||0)+1);} return [...counts.entries()].map(([name,qty])=>({name,qty})) }
